<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Hu's Blog - Scala / DOT</title><link href="/blog/" rel="alternate"></link><link href="/blog/feeds/scala-dot.atom.xml" rel="self"></link><id>/blog/</id><updated>2019-08-15T00:00:00-04:00</updated><entry><title>A Complement of My Thesis: Naming Conventions and Choice of Proof Assistants</title><link href="/blog/2019/agda-vs-coq.html" rel="alternate"></link><published>2019-08-15T00:00:00-04:00</published><updated>2019-08-15T00:00:00-04:00</updated><author><name>Jason Hu</name></author><id>tag:None,2019-08-15:/blog/2019/agda-vs-coq.html</id><summary type="html">&lt;p class="first last"&gt;An explanation of why I separate decidability analysis and algorithmic
analysis into Agda and Coq in the technical work of my master's thesis.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In my &lt;a class="reference external" href="https://gitlab.com/JasonHuZS/AlgDotCalculus"&gt;thesis&lt;/a&gt;, I exclusively used Agda
for decidability analysis and and Coq for algorithmic analysis. This decision is based
on an unobvious technical observation. This blog explains this technical observation,
and why it would have been extremely difficult to work out the same undecidability
proof in Coq.&lt;/p&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;To give a high-level summary, the main difficulties to establish the same proof in Coq
as in Agda are:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;inference rules live in Prop instead of Type,&lt;/li&gt;
&lt;li&gt;names are represented by locally nameless and cofinite representation in
formalization in Coq, and&lt;/li&gt;
&lt;li&gt;termination checking in Coq requires a specified decreasing structure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This difficulties are mainly encountered when attempting to show transitivity of
&lt;span class="math"&gt;\(D_{&amp;lt;:}\)&lt;/span&gt; normal form (Theorem 3.20).  These points requires more careful
technical setup to be fully clear.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="type-and-prop"&gt;
&lt;h2&gt;&lt;tt class="docutils literal"&gt;Type&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;&lt;/h2&gt;
&lt;p&gt;Though the majority of my work is in Coq, the undecidability proofs discussed in
Chapter 3, were done in Agda. This is not simply for reasons like “wow, it would be
cool to use two proof assistants”, but for something more fundamental.&lt;/p&gt;
&lt;p&gt;The first difficulty is about proof relevant universes versus proof irrelevant
universes. Up until Agda 2.5.4.2, Agda has no universe for propositions (but there is
one now in Agda 2.6+), which means the entire language resides in a predicative
universe hierarchy (called &lt;tt class="docutils literal"&gt;Set&lt;/tt&gt;s). On the other hand, Coq is way more
complicated. It has not only the predicative universe hierarchy as in Agda (called
&lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;s), but also other two universes, &lt;tt class="docutils literal"&gt;Set&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;. It is very
misleading that &lt;tt class="docutils literal"&gt;Set&lt;/tt&gt; in Coq is not the same as &lt;tt class="docutils literal"&gt;Set&lt;/tt&gt;s in Agda. Specifically,
&lt;tt class="docutils literal"&gt;Set&lt;/tt&gt; in Coq is a small universe which can only contain data. &lt;tt class="docutils literal"&gt;Set&lt;/tt&gt;s in Agda
corresponds to &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;s in Coq.&lt;/p&gt;
&lt;p&gt;The problem here is that &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; in Coq is a proof irrelevant universe. Proof
irrelevance is a concept stating that terms inhabited in types that are &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; are
purely logical and any two proofs of the same proposition are considered identical. A
&lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; in Coq can only be eliminated into data (&lt;tt class="docutils literal"&gt;Set&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;) when the
definition of the &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; satisfies &lt;em&gt;singleton elimination principle&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In programming languages, it is a convention to put inference rules in
&lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;. Therefore, libraries designed for programming languages researchers assumes
it is the case.&lt;/p&gt;
&lt;p&gt;First, let me explain what &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; cannot do. Consider the following two types.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \exists x, P(x) \\
  \Sigma x, P(x)
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The first one is existential quantification, which is typical in logic.  It simply
confirms the existence of something but gives away no precise information of the
witness. The second one is called a &lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; type and represents a pair, where
the type of the second element depends on the value of the first element. For example,
let us assume&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  x \in \{\text{morning}, \text{noon}, \text{evening}\}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;and &lt;span class="math"&gt;\(P\)&lt;/span&gt; is meal. If &lt;span class="math"&gt;\(x\)&lt;/span&gt; is morning, then &lt;span class="math"&gt;\(P(x)\)&lt;/span&gt; is breakfast, and
cereal is one of the values. If &lt;span class="math"&gt;\(x\)&lt;/span&gt; is evening, then &lt;span class="math"&gt;\(P(x)\)&lt;/span&gt; is dinner, and
steak is one of the values. Having a &lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; type, I can know the time,
together with a concrete proof that there will be a meal at that time. This is because
&lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; type stores data. In general,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Sigma x, P(x) \Rightarrow \exists x, P(x)\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This is because one can always forget about the information. Instead of saying the
information is about the dinner in the evening, I can always forget about the time and
only be concerned about the fact that there will be food for the day without even
caring about when it is. Clearly, I have lost information by going through this
direction.&lt;/p&gt;
&lt;p&gt;Though consistent with the theory, the other way is not generally provable.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \exists x, P(x) \nRightarrow \Sigma x, P(x)\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This direction requires an axiom, called the &lt;em&gt;indefinite description&lt;/em&gt; or &lt;em&gt;Hilbert’s&lt;/em&gt;
&lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;. This axiom turns out to be very strong as it can be used to prove
the axiom of choice. In short, the proof irrelevant nature of universe &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;
forgets the internal structures of derivations of inference rules and prevents
their treatment as pieces of data, because in &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;, any two proofs of the same
conclusion are considered the same.&lt;/p&gt;
&lt;p&gt;However, when considering undecidability proof, I have to consider interactions
between features in a judgment derivation using Gentzen's style of proof
induction. This, in turn, is to treat proofs as prices of structural data. This view
naturally contradicts to the philosophy of proof irrelevance.&lt;/p&gt;
&lt;p&gt;This problem is fundamental. Technically, the barrier between &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt; is
firm in Coq. Since there is virtually no way to extract data information from &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;
(except when the definition satisfies singleton elimination which is very often not
the case), if a proof step requires induction on a definition in &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;, then it
forces all other dependent definitions into &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; as well. An alternative solution
is to turn this definition a &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;, which is not always possible.&lt;/p&gt;
&lt;p&gt;In contrast, Agda has no proof irrelevant universe, so such problem simply does not
occur. Even in Agda 2.6, the majority of concepts are defined in &lt;cite&gt;Set&lt;/cite&gt;s, which
limits the troubles created by proof irrelevance.&lt;/p&gt;
&lt;p&gt;In my opinion, most of the proof techniques in programming languages are representable
in first order fragment of intuitionistic type theory, so requirement of &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; does
not look justified. For other proofs that cannot be shown in the first order fragment,
it is likely that having &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; is not going to resolve this issue.  It appears
&lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; does not give many advantages from this perspective. Therefore, working with
proof relevant universes had been a much better choice.&lt;/p&gt;
&lt;p&gt;It might still have been still possible to establish transitivity of &lt;span class="math"&gt;\(D_{&amp;lt;:}\)&lt;/span&gt;
normal form. However, a particular name representation had introduced significant
difficulties to the problem which makes establishment of the property very unlikely.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="name-representations"&gt;
&lt;h2&gt;Name Representations&lt;/h2&gt;
&lt;p&gt;In informal presentation of programming languages, we often use Barendregt's
convention of &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; conversions. That is, all terms and types are considered
the same if free variables are the permuted. In formal analysis, however, such
equivalence is too abstract to represent. Very often, other name representations are
used instead. Among these representation, de Bruijn indices are one choice. In de
Bruijn indices, each name is presented as a natural number, indexing the
telescope. Intuitively, de Bruijn indices take a quotient of the set of terms and
types over all names.&lt;/p&gt;
&lt;p&gt;Another possibility is locally nameless representation with cofinite quantification
(or LN-cofinite in short). In this representation, a name has dual representation: a
string when bound in the telescope, or a de Bruijn index when is closed in a term or a
type.&lt;/p&gt;
&lt;p&gt;There are many advantages of LN-cofinite in the context of soundness proofs. However,
this name representation does not have all advantages over other name representations,
and there is one particular issue with LN-cofinite which gives substantial trouble
with interacting with &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="cofinite-quantification"&gt;
&lt;h3&gt;Cofinite quantification&lt;/h3&gt;
&lt;p&gt;&lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; introduced LN-cofinite as an answer to the POPLmark challenges. In LN-cofinite,
when a fresh name is needed, such free name is specified by a universal
quantification, with a condition of not being contained in a specific finite name
store, hence &lt;em&gt;cofinite&lt;/em&gt;. For ease of presentation, I will use &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt; has an
example. Note that there are other ways to resolve the situation in &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt;,
because it is not as complicated as &lt;span class="math"&gt;\(D_{&amp;lt;:}\)&lt;/span&gt;. I use &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt; only
because it has less rules and it is exposed to the same problem.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
&amp;amp;\dfrac{ }{\Gamma \vdash T &amp;lt;: \top} \text{(Top)} \quad
\dfrac{ }{\Gamma \vdash X &amp;lt;: X} \text{(Refl)} \quad
\dfrac{X &amp;lt;: T \in \Gamma \quad \Gamma \vdash T &amp;lt;: U}{\Gamma \vdash X &amp;lt;: U}
\text{(Var)} \\\\
&amp;amp;\dfrac{\Gamma \vdash S_2 &amp;lt;: S_1 \quad \Gamma ; X &amp;lt;: S_2 \vdash U_1 &amp;lt;: U_2}{\Gamma
\vdash \forall X &amp;lt;: S_1. U_1 &amp;lt;: \forall X &amp;lt;: S_2. U_2} \text{(All)}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Notice that this definition of &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt; uses Barendregt's convention as it
implicitly requires &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; conversion in the All rule when drawing a fresh
&lt;span class="math"&gt;\(X\)&lt;/span&gt; as a type variable.  A formal definition using LN-cofinite would define the
All rule alternatively as follows:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{\Gamma \vdash S_2 &amp;lt;: S_1 \quad \Pi X, X \notin L \to \Gamma ; X &amp;lt;: S_2 \vdash U_1 &amp;lt;: U_2}{\Gamma
\vdash \forall X &amp;lt;: S_1. U_1 &amp;lt;: \forall X &amp;lt;: S_2. U_2} \text{(All')}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;I use &lt;span class="math"&gt;\(\Pi\)&lt;/span&gt; to denote universal quantification in type theory, in order to
distinguish the symbol &lt;span class="math"&gt;\(\forall\)&lt;/span&gt; which has been used as a part of the syntax in
&lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Notice that, in this formal definition, &lt;span class="math"&gt;\(L\)&lt;/span&gt; is a finite name store. The second
premise in All' holds for any &lt;span class="math"&gt;\(X\)&lt;/span&gt; that is not contained in &lt;span class="math"&gt;\(L\)&lt;/span&gt;.  That is,
in this judgment, it remembers a finite set of names &lt;span class="math"&gt;\(L\)&lt;/span&gt;, and the fresh names
drawn in the second premise must avoid &lt;span class="math"&gt;\(L\)&lt;/span&gt;. Since the set of all names are
countably infinite, excluding a finite number of them will not exclude all names. In
a universal type, e.g.  &lt;span class="math"&gt;\(\forall X &amp;lt;:S.U\)&lt;/span&gt;, &lt;span class="math"&gt;\(X\)&lt;/span&gt; on the other hand, is
presented by a de Bruijn index, and it is 0 in this case.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="noncanonical-derivation-of-cofinite-quantification"&gt;
&lt;h3&gt;Noncanonical derivation of cofinite quantification&lt;/h3&gt;
&lt;p&gt;LN-cofinite captures much intuition, but there are gaps between it and Barendregt's
convention. In particular, with &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; conversion, we usually consider a
given derivation has fixed subderivations; namely, the shape of any subderivation is
fixed up to permutations of names. This assumption, unfortunately, is &lt;em&gt;false&lt;/em&gt; with
LN-cofinite.&lt;/p&gt;
&lt;p&gt;Let us consider the All' rule again:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{\Gamma \vdash S_2 &amp;lt;: S_1 \quad \Pi X, X \notin L \to \Gamma ; X &amp;lt;: S_2 \vdash U_1 &amp;lt;: U_2}{\Gamma
\vdash \forall X &amp;lt;: S_1. U_1 &amp;lt;: \forall X &amp;lt;: S_2. U_2} \text{(All')}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;In this rule, the second premise resides in a universal quantification, which is a
function space in the type theory. Since it is a &lt;span class="math"&gt;\(\Pi\)&lt;/span&gt; type, the proof term is
some function. Consider the following implementation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;fun&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_notin_L&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;notin&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="c"&gt;(* ... a proof term specialized for Y *)&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="c"&gt;(* ... a proof term specialize for Z *)&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="c"&gt;(* ... other proof terms *)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In particular, proof terms when &lt;span class="math"&gt;\(Y\)&lt;/span&gt; is picked and &lt;span class="math"&gt;\(Z\)&lt;/span&gt; is picked do not
have to look the same. This is even worse when transitivity and reflexivity are a part
of the definition. For any derivation &lt;span class="math"&gt;\(D\)&lt;/span&gt; which witnesses &lt;span class="math"&gt;\(\Gamma \vdash S
&amp;lt;: U\)&lt;/span&gt;, following derivation is also a witness of the same conclusion:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{\Gamma \vdash S &amp;lt;: U \quad \Gamma \vdash U &amp;lt;: U\text{(Refl)}}{\Gamma \vdash S &amp;lt;: U}\text{(Trans)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Define this trivial expansion of derivation tree &lt;span class="math"&gt;\(f(D)\)&lt;/span&gt;. Since a set of names
excluding any finite set remains countably infinite, there exists an isomorphism
between this set and natural numbers. Call this isomorphism &lt;span class="math"&gt;\(I\)&lt;/span&gt;. Consider a
proof &lt;span class="math"&gt;\(H\)&lt;/span&gt; witnessing &lt;span class="math"&gt;\(\Pi X, X \notin L \rightarrow
\Gamma; X &amp;lt;: S' \vdash U_X &amp;lt;: U'_X\)&lt;/span&gt;.  Then one can derive a proof term, so that
the forms of the subtyping derivations between return types generated by different
type variables are completely “distorted”.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  H' &amp;amp;: \Pi X, X \notin L \Rightarrow \Gamma; X &amp;lt;: S' \vdash U_X &amp;lt;: U'_X \\
  H' &amp;amp;:= \lambda X (N : X \notin L). Rec(I(X), H(X, N))  \\
  Rec(0, D) &amp;amp;:= D \\
  Rec(1 + n, D) &amp;amp;:= Rec(n, f(D))
  \end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The idea is that &lt;span class="math"&gt;\(H'\)&lt;/span&gt; expands an existing proof &lt;span class="math"&gt;\(H\)&lt;/span&gt; using the expansion
function above so that a pair of derivations generated by two difference choices of
names are not going to be the same.&lt;/p&gt;
&lt;p&gt;In the construction of &lt;span class="math"&gt;\(H'\)&lt;/span&gt;, I first extract an existing proof from
&lt;span class="math"&gt;\(H\)&lt;/span&gt;. Then for any given valid choice of name &lt;span class="math"&gt;\(X\)&lt;/span&gt;, the isomorphism
&lt;span class="math"&gt;\(I\)&lt;/span&gt; between the set of names and natural numbers converts &lt;span class="math"&gt;\(X\)&lt;/span&gt; to a natural
number. This natural number is used to count the number of interations of applications
of &lt;span class="math"&gt;\(f\)&lt;/span&gt; to the existing proof. Since any two distinct names are not mapped to the
same natural numbers, and there are infinite number of names, it is clear that sizes
of derivations in &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt; are in generally not measurable by natural numbers.&lt;/p&gt;
&lt;p&gt;On the other hand, we assume derivations are trees and therefore their depths can be
measured by natural numbers. This distinction is not quite compatible with the
classical view of Gentzen's style proof induction.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="termination-checking"&gt;
&lt;h2&gt;Termination Checking&lt;/h2&gt;
&lt;p&gt;Before turning our attention to the problem with LN-cofinite, it is worth briefly
mentioning the strategies of termination checking in Coq and Agda.&lt;/p&gt;
&lt;p&gt;Though very often inferred, termination checking in Coq indeed requires a specified
&lt;tt class="docutils literal"&gt;struct&lt;/tt&gt; parameter so that the termination checker knows which structure the
fixpoint decreases on. This strategy works similar in both &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt; in
Coq.&lt;/p&gt;
&lt;p&gt;On the other hand, in Agda, the strategy is slightly different. In Agda, the
termination checker directly checks each call site of the function being defined (or
functions in the context of mutual definitions) to ensure the parameters are
decreasing in a lexicographical order. Note that this method is weaker than the one used
in Coq, though ultimately equivalent as it can be done manually in Coq by using some
well-founded induction.&lt;/p&gt;
&lt;p&gt;That being said, sometimes this distinction can induce significant differences of
engineering effort. The problem is much easier to surface when considering
well-founded induction of some &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;, e.g. well-founded induction on the depth of
the derivations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="interacting-with-prop"&gt;
&lt;h2&gt;Interacting with &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;&lt;/h2&gt;
&lt;p&gt;There are various proofs in my thesis requiring well-founded induction on the number
of steps in the derivation of a judgment. On paper, this is usually not a problem; as
indicated earlier, we often consider a derivation is a (finite) tree and therefore
there is always a maximum depth of a derivation, following Gentzen's style. However,
in a previous section, I showed that this view is not well compatible with
LN-cofinite, as there are subderivations living in function spaces. Note that I will
be using &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt; as an example here for ease of presentation. However, there
are workarounds for the problem presented here, so &lt;span class="math"&gt;\(F_{&amp;lt;:}^-\)&lt;/span&gt; itself does not
suffer much from it. My point is that, in more sophisticated proofs like transitivity
of &lt;span class="math"&gt;\(D_{&amp;lt;:}\)&lt;/span&gt;, due to the intervene of complex inductive scheme, a workaround does
not seem to exist, and therefore the problem about to be presented here is more
significant for those calculi.&lt;/p&gt;
&lt;p&gt;Let us consider how to measure the size of a derivation if it is defind in
&lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;. As shown previously, natural numbers are not big enough, so the following
definition is used instead.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;Inductive&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;rec&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;clsr&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;notin&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;card&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this definition, &lt;tt class="docutils literal"&gt;card&lt;/tt&gt; stands for cardinal. If the subtyping relation is defined
in &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;, then a function can be defined to convert the derivation to &lt;tt class="docutils literal"&gt;card&lt;/tt&gt;. One
can easily define a well-founded relation on &lt;tt class="docutils literal"&gt;card&lt;/tt&gt;, and therefore it is possible to
do well-founded induction with LN-cofinite.  However, if the subtyping relation is
defined in &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;, as it is usually done, then &lt;tt class="docutils literal"&gt;card&lt;/tt&gt; does not measure the size of
a derivation anymore.&lt;/p&gt;
&lt;p&gt;The first trouble is, one cannot define a function converting a derivation to a
&lt;tt class="docutils literal"&gt;card&lt;/tt&gt;, because it would require elimination from &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;, which is in
general not possible except when the &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; satisfies singleton elimination
principle.&lt;/p&gt;
&lt;p&gt;A possible solution to this, is to use a relation to associate every derivation with a
measure. That is the following equivalence:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Gamma \vdash S &amp;lt;: U \Leftrightarrow \exists c, \Gamma \vdash [ c ] S &amp;lt;: U
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The equivalence shows an equivalence between the original subtyping relation and an
enriched subtyping relation, denoted by &lt;span class="math"&gt;\(\Gamma \vdash [ c ] S &amp;lt;: U\)&lt;/span&gt;. In this
relation, &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt;, &lt;span class="math"&gt;\(S\)&lt;/span&gt; and &lt;span class="math"&gt;\(U\)&lt;/span&gt; represent precisely what
&lt;span class="math"&gt;\(\Gamma \vdash S &amp;lt;: U\)&lt;/span&gt; means. In addition to that, a fourth parameter &lt;span class="math"&gt;\(c\)&lt;/span&gt;
represents the cardinal of &lt;span class="math"&gt;\(\Gamma \vdash S &amp;lt;: U\)&lt;/span&gt;, defined by &lt;tt class="docutils literal"&gt;card&lt;/tt&gt;
aboved. That is, &lt;span class="math"&gt;\(c\)&lt;/span&gt; is used to remember the cardinal of a given subtyping
derivation.  For completeness, the full definition of this four-place relation is
defined as follows:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
&amp;amp;\dfrac{ }{\Gamma \vdash [\texttt{base}] T &amp;lt;: \top} \text{(C-Top)} \quad
\dfrac{ }{\Gamma \vdash [\texttt{base}] X &amp;lt;: X} \text{(C-Refl)} \\\\\
&amp;amp;\dfrac{X &amp;lt;: T \in \Gamma \quad \Gamma \vdash [\texttt{c}] T &amp;lt;: U}{\Gamma \vdash [\texttt{rec
c}] X &amp;lt;: U}
\text{(C-Var)} \\\\
&amp;amp;\dfrac{\Gamma \vdash [\texttt{c}] S_2 &amp;lt;: S_1 \quad \Pi\; X\; (NI : X \notin L), \Gamma ;
X &amp;lt;: S_2 \vdash [\texttt{d X NI}] U_1 &amp;lt;: U_2}{\Gamma
\vdash [\texttt{clsr c d}] \forall X &amp;lt;: S_1. U_1 &amp;lt;: \forall X &amp;lt;: S_2. U_2} \text{(C-All)}
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Reviewing these rules, one can realize that indeed the cardinal measures a
derivation. It is easy to show that&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \exists c, \Gamma \vdash [ c ] S &amp;lt;: U \Rightarrow \Gamma \vdash S &amp;lt;: U
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This can be proved by forgetting &lt;span class="math"&gt;\(c\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;However, the other direction is not quite easy.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\begin{aligned}
  \Gamma \vdash S &amp;lt;: U \Rightarrow \exists c, \Gamma \vdash [ c ] S &amp;lt;: U
\end{aligned}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This is because the subtyping relation lives in &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; and that the All' rule uses a
function space for its subderivation. Consider a proof attempt by induction. The All'
rule generates the following antecedents in the proof context:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\Gamma \vdash S_2 &amp;lt;: S_1\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\Pi X, X \notin L \to \Gamma ; X &amp;lt;: S_2 \vdash U_1 &amp;lt;: U_2\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\Gamma \vdash [\texttt{c}] S_2 &amp;lt;: S_1\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\Pi X, X \notin L \to \exists d, \Gamma ; X &amp;lt;: S_2 \vdash [\texttt{d}] U_1 &amp;lt;: U_2\)&lt;/span&gt;,&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The goal is&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\exists e, \Gamma \vdash [\texttt{e}] \forall X &amp;lt;: S_1. U_1 &amp;lt;: \forall X &amp;lt;: S_2. U_2
\end{equation*}
&lt;/div&gt;
&lt;p&gt;According to the C-All rule, this &lt;span class="math"&gt;\(e\)&lt;/span&gt; is constructed by &lt;tt class="docutils literal"&gt;clsr&lt;/tt&gt;, and &lt;cite&gt;c&lt;/cite&gt; is
already known. The trouble is &lt;span class="math"&gt;\(d\)&lt;/span&gt;, which has type &lt;span class="math"&gt;\(\Pi X, X \notin L \to
\texttt{card}\)&lt;/span&gt;.  This ought to be constructed from the fourth antecedent. However,
this cannot be done. Notice that this target type is in &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;, while the fourth
antecedent lives in &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt;. Due to the isolation between &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt;, one
cannot construct a &lt;tt class="docutils literal"&gt;Type&lt;/tt&gt; out of &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; (clearly this function space does not
satisfy singleton elimination).&lt;/p&gt;
&lt;p&gt;Looking at the form of the fourth antecedent, to derive &lt;span class="math"&gt;\(\Pi X, X \notin L \to
\texttt{card}\)&lt;/span&gt;, at least the axiom of Choice seems necessary. Surely this can be done
by postulating it, as Choice is compatible with Coq. If one resists postulating axioms
in type theory, it has come to a deadend. Yet, if de Bruijn indices are used, there is
no need to use other axioms. Namely, &lt;span class="math"&gt;\(\Gamma \vdash S &amp;lt;: U \Rightarrow \exists
c, \Gamma \vdash [ c ] S &amp;lt;: U\)&lt;/span&gt; can already be proven purely constructively with de
Bruijn indices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this blog, I showed that how LN-cofinite interacts with &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; and introduces the
need of some external axiom. This is quite unexpected, as it has nothing to do with
Barendregt's convention at all, but is a very technical detail of the choice of name
representation. With Gentzen's style proof induction, one treats proof derivations as
trees which directly conflicts with the nature of LN-cofinite. It means that the
choice of name representation is highly non-trivial depending on the problems and the
use of &lt;tt class="docutils literal"&gt;Prop&lt;/tt&gt; universe needs to be carefully reviewed.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The Locally Nameless Representation, &lt;a class="reference external" href="https://www.chargueraud.org/research/2009/ln/main.pdf"&gt;https://www.chargueraud.org/research/2009/ln/main.pdf&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Scala / DOT"></category><category term="DOT"></category><category term="programming languages"></category><category term="research"></category><category term="proof assistants"></category></entry><entry><title>Subtyping with Algebra</title><link href="/blog/2019/sub-alg.html" rel="alternate"></link><published>2019-05-12T00:00:00-04:00</published><updated>2019-05-12T00:00:00-04:00</updated><author><name>Jason Hu</name></author><id>tag:None,2019-05-12:/blog/2019/sub-alg.html</id><summary type="html">&lt;p class="first last"&gt;Study subtyping in an algebraic approach!&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;When the subtyping relation in a programming language is rich enough, the relation
starts to induce some algebraic structure. For example, DOT has intersection types,
which admits bounded semi-lattice structure, both order theoretically and
algebraically. However, intersection types in DOT have only been studied in its order
theoretic nature (probably not even, because order theory studies nothing about the
contexts!), but nothing about its algebra.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;In my work of &lt;a class="reference external" href="https://gitlab.com/JasonHuZS/AlgDotCalculus"&gt;Master's thesis&lt;/a&gt;, I
studied a simplified version of DOT, &lt;span class="math"&gt;\(D_{\wedge}\)&lt;/span&gt; (pronounced &lt;em&gt;Dee
Intersect&lt;/em&gt;). This calculus has intersection types and data field members. For example,
&lt;span class="math"&gt;\(\{a : S \wedge U\}\)&lt;/span&gt; denotes a data field member, the tag of which is &lt;span class="math"&gt;\(a\)&lt;/span&gt;
and the type is &lt;span class="math"&gt;\(S \wedge U\)&lt;/span&gt;. In general, intersection types specify refinement
of information. The subtyping rules are as follows.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{ }{\Gamma \vdash S \wedge U &amp;lt;: S}(\text{And-E1})
\quad
\dfrac{ }{\Gamma \vdash S \wedge U &amp;lt;: U}(\text{And-E2})
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{\Gamma \vdash T &amp;lt;: S \quad \Gamma \vdash T &amp;lt;: U}
{\Gamma \vdash T &amp;lt;: S \wedge U}(\text{And-I})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The first two rules says that one can feel free to drop information from intersection
types, and the third rule asserts that the intersection type is the greatest subtype
of &lt;span class="math"&gt;\(S\)&lt;/span&gt; and &lt;span class="math"&gt;\(U\)&lt;/span&gt;. If &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; is not specified, then these rules are
an axiomatization of order theoretic meet-semilattice. Together with &lt;span class="math"&gt;\(\top\)&lt;/span&gt;
type, which is the supertype of all types, this forms an order theoretic bounded
meet-semilattice structure.&lt;/p&gt;
&lt;p&gt;So far so natural. However, it's textbook knowledge that order theoretic
meet-semilattice and algebraic meet-semilattice are interchangeable. Namely, order
theoretic meet-semilattice induces algebraic structure. Define the &lt;em&gt;induced type
equivalence relation&lt;/em&gt; as follows.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\Gamma \vdash S \approx U \equiv \Gamma \vdash S &amp;lt;: U \times \Gamma \vdash U &amp;lt;: S
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Namely, two types are equivalent, if they are a subtype of each other in the given
context. So it's easy to see that.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\Gamma \vdash S \wedge U \approx U \wedge S
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This property is called &lt;em&gt;commutativity&lt;/em&gt;. In general, regardless of the contexts,
algebraic bounded semilattice admits all following properties.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\top \wedge T &amp;amp;\approx T &amp;amp;(\text{identity}) \\
S \wedge U &amp;amp;\approx U \wedge S &amp;amp;(\text{commutativity}) \\
(S \wedge T) \wedge U &amp;amp;\approx S \wedge (T \wedge U) &amp;amp;(\text{associativity}) \\
T \wedge T &amp;amp;\approx T &amp;amp;(\text{idempotency})
\end{align*}
&lt;/div&gt;
&lt;p&gt;One can prove all of the above using the subtyping relation above.&lt;/p&gt;
&lt;p&gt;What's more, one might expect that intersection types distribute accross data field
members. Namely,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\Gamma \vdash \{ a : S \} \wedge \{a : U\} \approx \{a : S \wedge U\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Note that the type on the left is already provably a supertype of the right, because
intersection types are the greatest subtypes. However, this type cannot be shown a
subtype of the right. This requires an axiom, like following&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac{ }
{\Gamma \vdash \{ a : S \} \wedge \{a : U\} &amp;lt;: \{a : S \wedge U\}}
(\text{Fld-Distr})
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This rule is required to be an axiom because it cannot be proved by any other existing
rules. This is normally how it's done in other people's work, but looking at this
rule, it's easy to realize that it is the algebraic relation that is wanted, not this
particular subtyping relation. This axiom is here just to make sure the subtyping
relation &lt;em&gt;induces&lt;/em&gt; a desired algebraic relation, but nothing more. Therefore, a
question arises: why not reason about the algebraic structure directly?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="algebraic-structure-in-subtyping"&gt;
&lt;h2&gt;Algebraic Structure in Subtyping&lt;/h2&gt;
&lt;p&gt;This is very interesting way of thinking about subtyping. Algebraic approaches are not
rare in type theoretic study, but somehow, subtyping doesn't quite look &amp;quot;type
theoretic&amp;quot;. On the other hand, people seem to avoid this way of thinking because it
simply adds a great deal of difficulties in the study. This is because algebraic
structure in its essence is &amp;quot;more precise&amp;quot; than subtyping relation, and therefore
subtyping relation can only be built after the algebra is defined, but not the other
way around. Visually, a hierarchy like&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\text{Type (raw)} \to \text{Algebra (without context)} \to \text{Subtyping (with contexts)}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;needs to be defined.&lt;/p&gt;
&lt;p&gt;Another reason is what we have in proof assistants is not sufficient to
reason about these nested structures efficiently. To give a good feeling of how
cumbersome it can be, I formalized a very primitive algebraic relation in
&lt;span class="math"&gt;\(D_{\wedge}\)&lt;/span&gt; &lt;a class="reference external" href="https://gitlab.com/JasonHuZS/AlgDotCalculus/blob/master/agda/DintAlg.agda"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;infix&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;_≃_&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;_≃_&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Typ&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Typ&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;Set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;where&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;refl&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;T&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;tran&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;symm&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;assoc&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;comm&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;U&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;S&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;idem&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;T&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;⊤∩&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;T&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;⊤&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;⊥∩&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;∀&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;T&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;→&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;⊥&lt;span class="w"&gt; &lt;/span&gt;∩&lt;span class="w"&gt; &lt;/span&gt;T&lt;span class="w"&gt; &lt;/span&gt;≃&lt;span class="w"&gt; &lt;/span&gt;⊥&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;∩-cong&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;_∩_&lt;span class="w"&gt; &lt;/span&gt;Preserves₂&lt;span class="w"&gt; &lt;/span&gt;_≃_&lt;span class="w"&gt; &lt;/span&gt;⟶&lt;span class="w"&gt; &lt;/span&gt;_≃_&lt;span class="w"&gt; &lt;/span&gt;⟶&lt;span class="w"&gt; &lt;/span&gt;_≃_&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are more axioms than listed above. This is because some axioms are needed to
impose the equivalence relation which does not originally hold if a relation is
defined from scratch. At last, the congruence property &lt;cite&gt;∩-cong&lt;/cite&gt; also needs to be
asserted to ensure the equivalence is congruence everywhere in the intersection
types. Then it follows the properties of this equivalence, like proving this
equivalence respects the subtyping relation, as well as other algebraic
theorems. Moreover, this equivalence is very hard to work with, so to make things a
bit easier, more auxiliary concepts need to be defined. What a pain.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cubical-type-theory"&gt;
&lt;h2&gt;Cubical Type Theory&lt;/h2&gt;
&lt;p&gt;This sort of algebraic study is painful, because even the basic structure of the
relation requires &lt;em&gt;proofs&lt;/em&gt;. For example, this relation is not an equivalence by birth;
it is only after a proof is established. Due to this, the congruence properties
require more proofs and it's probably the most boring thing to do.&lt;/p&gt;
&lt;p&gt;However, this is not a deadend. Cubical type theory is a richer theory than
intuitionistic type theory and a more helpful one when reasoning about &amp;quot;algebras up to
equivalences&amp;quot;. In cubical type theory, higher inductive types (HIT) allow data to
carry internal algebraic structure. For example, one can define &lt;span class="math"&gt;\(S \wedge U = U
\wedge S\)&lt;/span&gt; by definition. This means from the outside world, when a &lt;span class="math"&gt;\(D_{\wedge}\)&lt;/span&gt;
type is perceived, it's that type up to algebra as desired above. What's more, it's
perfectly congurent, due to the type theory.&lt;/p&gt;
&lt;p&gt;Then looking back to what was wanted above,&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\{ a : S \} \wedge \{a : U\} \approx \{a : S \wedge U\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;If we define&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(T) \equiv \{a : T\}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f(S) \wedge f(U) \approx f(S \wedge U)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;simply means that data field members are semi-lattice homomorphism. From category
theoretic point of view, &lt;span class="math"&gt;\(f\)&lt;/span&gt; is considered functorial. Everything starts to look
very simple from this point on. Moreover, the subtyping relation can remain untouched.
It simply gives more structure to the underlying definition of types in
&lt;span class="math"&gt;\(D_{\wedge}\)&lt;/span&gt;. The theory therefore gives more structure than
intuitionistic type theory in order to study the problem, which does not seem to be
explored at the moment. I am very interested to see how this new type theory can
change the way people think about problems in.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Every problem in DOT is very difficult and tricky. At least it is the case at this
moment. One good way to tackle this problem should be to lower the difficulty of the
problem itself by improving the tools, not necessarily to invest more time on tackle a
hard problem. I feel that cubical type theory is the right type theory to talk about
DOT. However, changing the way of thinking is never an easy task to begin with. I hope
one day type theory can be so advanced that even DOT becomes a piece of cake.&lt;/p&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Scala / DOT"></category><category term="DOT"></category><category term="programming languages"></category><category term="research"></category><category term="type theory"></category><category term="proof assistants"></category></entry><entry><title>Comparison Between Different DOTs</title><link href="/blog/2019/compare-dots.html" rel="alternate"></link><published>2019-03-09T00:00:00-05:00</published><updated>2019-03-09T00:00:00-05:00</updated><author><name>Jason Hu</name></author><id>tag:None,2019-03-09:/blog/2019/compare-dots.html</id><summary type="html">&lt;p class="first last"&gt;A comparison between different versions of Dependent Object Types
(DOTs). The thought put in this blog might or might not be published in the
future, but nonetheless something worth mentioning before I entirely forget
about it.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Last week, Ondřej, Marianna and I were discussing the differences between two
different definitions of Dependent Object Types (DOTs). The original motivation was
that I had to make the technical decision of which DOT I am supposed to work on for my
&lt;a class="reference external" href="https://gitlab.com/JasonHuZS/AlgDotCalculus"&gt;Master's thesis&lt;/a&gt;. Though the decision
was made before the discussion occurred, I think the discussion was very fruitful, and
it should be made public. I am not sure if the content from this blog will eventually
become a paper, because it depends on my timeline, as well as Ondřej's. On the other
hand, I suppose it's very important for a researcher who attempts to work on DOT, and
wants to make their technical decision as well.&lt;/p&gt;
&lt;p&gt;Here, I will focus my discussion on OOPSLA DOT &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; and Wadlerfest DOT &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[2]&lt;/a&gt;. Due to
limitation of space, it would directly dive into the technical details, without going
through the definition of the calculi. Going through all the definitions of DOTs
should really be the content of a survey paper, which is not what I am doing now, so
I'd expect this article might appear to be difficult for beginners.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-comparison"&gt;
&lt;h2&gt;The Comparison&lt;/h2&gt;
&lt;p&gt;Following are some discussion on the calculi, but before that, I should probably
describe a main feature in these calculi to make the problem clearer.&lt;/p&gt;
&lt;div class="section" id="path-dependent-types"&gt;
&lt;h3&gt;Path Dependent Types&lt;/h3&gt;
&lt;p&gt;In Scala, a class can have type members. In DOT, we call it type tags.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;???&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// then in the future, one may refer to the type inside of Foo&lt;/span&gt;
&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;???&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the notation &lt;span class="math"&gt;\(&amp;gt;:\)&lt;/span&gt; means that &lt;cite&gt;Foo&lt;/cite&gt; is some subtype of &lt;cite&gt;A&lt;/cite&gt;, and &lt;span class="math"&gt;\(&amp;lt;:\)&lt;/span&gt;
means &lt;cite&gt;Bar&lt;/cite&gt; is some supertype of &lt;cite&gt;A&lt;/cite&gt;. Now consider the following piece of code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;???&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;x.A&lt;/cite&gt; in the second line is what we called &lt;em&gt;path dependent types&lt;/em&gt;. We refer to the
hidden type inside of the object via member access. This piece of code shows something
very strange. To begin with, the code has nothing to do with particular &lt;cite&gt;Foo&lt;/cite&gt; or
&lt;cite&gt;Bar&lt;/cite&gt;. That means one can turn any types into any other types. From theoretical point
of view, in the core calculus, we don't really need this assignment sequence to
achieve the same result. Instead, we rely on a fundamental property from the calculus,
transitivity.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash S &amp;lt;: T \quad \Gamma \vdash T &amp;lt;: U}{\Gamma \vdash S &amp;lt;: U} (Trans)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Relying on transitivity, we can derive &lt;cite&gt;z1&lt;/cite&gt; having type &lt;cite&gt;Bar&lt;/cite&gt; immediately. However,
such derivation can only be made possible, if &lt;cite&gt;x&lt;/cite&gt; is in the context to begin
with. Namely, there needs to be some instance of &lt;cite&gt;Foo&lt;/cite&gt; we can refer to: note that path
dependent types only works for existing variables. We refer to this characteristic of
connecting two arbitrary types with a path dependent type (or &lt;em&gt;path&lt;/em&gt; in short), &lt;strong&gt;bad
bounds&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This is a core feature in the new Scala, Dotty, and these two calculi are supposed to
model the behavior of path dependent types.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="context-truncation-in-oopsla-dot"&gt;
&lt;h3&gt;Context Truncation in OOPSLA DOT&lt;/h3&gt;
&lt;p&gt;In OOPSLA DOT, we can discover that the &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules have the following form
(e.g. &lt;span class="math"&gt;\(Sel_1\)&lt;/span&gt;).&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma_{[x]} \vdash x :_! (L : T .. \top)}{\Gamma \vdash T &amp;lt;: x.L} (Sel_1)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;In this notation, &lt;span class="math"&gt;\(\Gamma_{[x]}\)&lt;/span&gt; denotes that the bindings after &lt;span class="math"&gt;\(x\)&lt;/span&gt; from
context &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; are truncated (but &lt;span class="math"&gt;\(x\)&lt;/span&gt; is kept).&lt;/p&gt;
&lt;p&gt;On the other hand, Wadlerfest DOT has no such truncation.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : \{L : S .. U \}}{\Gamma \vdash S &amp;lt;: x.L} (Sel_1')
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This treatment, effectively, is used to regulate the behavior of path dependent
types. Note that in OOPSLA DOT, the typing is done via a variant with a bang
subscript. This difference will be discussed in the next section.  For the current
problem, consider the following (strange) program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nc"&gt;Any&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nc"&gt;Any&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nc"&gt;Nothing&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Nothing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Consider the generic type of &lt;cite&gt;List&lt;/cite&gt; can be accessed via &lt;cite&gt;x.T&lt;/cite&gt;. In Wadlerfest DOT, this
is a valid program, as witnessed by the following proof.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac
{\dfrac{x,y \vdash x : List[Any] \quad x,y \vdash List[Any] &amp;lt;: List[Nothing]}
{x,y \vdash x : List[Nothing]}}
{x,y \vdash x.T &amp;lt;: Nothing} (Sel_1/Sel_1')
\end{equation*}
&lt;/div&gt;
&lt;p&gt;For brievity, I omitted the types bound to the variables in the context, and some
sub-derivations that are obvious to see. However, in OOPSLA DOT, the subderivation of
&lt;span class="math"&gt;\(x,y \vdash List[Any] &amp;lt;: List[Nothing]\)&lt;/span&gt; doesn't work. This is because the
context truncation in the &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules. Since &lt;span class="math"&gt;\(x,y \vdash x.T &amp;lt;: Nothing\)&lt;/span&gt;
is a conclusion of &lt;span class="math"&gt;\(Sel_2\)&lt;/span&gt; rule, any sub-derivations after that point have lost
&lt;span class="math"&gt;\(y\)&lt;/span&gt;, and that makes this derivation impossible in the OOPSLA DOT. There doesn't
seem to other way to achieve the same conclusion in OOPSLA DOT either.&lt;/p&gt;
&lt;p&gt;That's why I called context truncation behavior is &lt;strong&gt;regulating&lt;/strong&gt; the behavior of path
dependent types. Due to the context truncation, how a path dependent type can behave
is fixed at its definition time.  There is no way to impose further subtyping relation
after that. Whereas in Wadlerfest DOT, this is possible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="typing-doesn-t-have-pack-rule"&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(:!\)&lt;/span&gt; Typing Doesn't Have &lt;span class="math"&gt;\(Pack\)&lt;/span&gt; rule&lt;/h3&gt;
&lt;p&gt;As briefly mentioned above, there is yet another distinction between these two DOTs,
which is the bang type (&lt;span class="math"&gt;\(:!\)&lt;/span&gt;) in OOPSLA DOT. In OOPSLA DOT, there are following
two rules.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : T^x}{\Gamma \vdash x : \{z \Rightarrow T^z\}} (VarPack)
\quad
\frac{\Gamma \vdash x :_{(!)} \{z \Rightarrow T^z\}}{\Gamma \vdash x :_{(!)} T^x} (VarUnpack)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The subscript &lt;span class="math"&gt;\((!)\)&lt;/span&gt; means that there is variant of the same rule for bang typing
(and without the subscript denote the regular typing). The formulation of these two
rules means that during bang typing, there cannot be &lt;span class="math"&gt;\(VarPack\)&lt;/span&gt; rule. The entries
for bang typing is &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules (see one rule in the previous section). In
Wadlerfest DOT, the similar rules are&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : T^x}{\Gamma \vdash x : \mu\{z : T^z\}} (Rec-I)
\quad
\frac{\Gamma \vdash x : \mu\{z : T^z\}}{\Gamma \vdash x : T^x} (Rec-E)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The syntax is different but &lt;span class="math"&gt;\(\{x \Rightarrow T^x\}\)&lt;/span&gt; and &lt;span class="math"&gt;\(\mu\{x : T^x\}\)&lt;/span&gt;
are the same thing. They both denote object types, which means all members in their
definitions can refer back to the object reference, and therefore their sibling
definitions as well. Now, consider how disallowing &lt;span class="math"&gt;\(VarPack\)&lt;/span&gt; rule (or
correspondingly &lt;span class="math"&gt;\(Rec-I\)&lt;/span&gt; rule) impact the expressiveness of the calculus.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
T_1 &amp;amp;= \{A : \bot .. \top \} \\
T_2 &amp;amp;= \{A : \bot .. \bot \} \\
T_3 &amp;amp;= \{ foo : x.A \} \\
T_4 &amp;amp;\text{ is irrelevant and not }\top.
\end{align*}
&lt;/div&gt;
&lt;p&gt;The we can consider the following program.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\text{def bar}&amp;amp; (y : \{ B :  \{z \Rightarrow T_1 \wedge T_4 \} .. \{ z \Rightarrow T_2 \wedge T_4\} \} ) \\
              &amp;amp; (x : \{x \Rightarrow T_1 \wedge T_3 \} \wedge T_4) \\
    : &amp;amp; \bot = x.foo
\end{align*}
&lt;/div&gt;
&lt;p&gt;In Wadlerfest, this program is going to compile, because &lt;span class="math"&gt;\(x : \{x \Rightarrow
T_1 \wedge T_4\}\)&lt;/span&gt; can be shown, by first &lt;span class="math"&gt;\(Rec-E\)&lt;/span&gt; rule and then &lt;span class="math"&gt;\(Rec-I\)&lt;/span&gt;
rule. After that, &lt;span class="math"&gt;\(y\)&lt;/span&gt; can be used to prove &lt;span class="math"&gt;\(x : \{x \Rightarrow T_2 \wedge
T_4\}\)&lt;/span&gt;. At this point, we've already got &lt;span class="math"&gt;\(\{A : \bot .. \bot\}\)&lt;/span&gt; and been able to
show &lt;span class="math"&gt;\(x.foo : \bot\)&lt;/span&gt; indeed.&lt;/p&gt;
&lt;p&gt;This, however, is impossible, because there is no way to show &lt;span class="math"&gt;\(x : \{x
\Rightarrow T_2 \wedge T_4\}\)&lt;/span&gt; inside of &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules, in which &lt;span class="math"&gt;\(VarPack\)&lt;/span&gt;
rule is forbidden. This gives another point OOPSLA DOT is less expressive than
Wadlerfest DOT.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="multi-inherience-in-dots"&gt;
&lt;h3&gt;Multi-Inherience in DOTs&lt;/h3&gt;
&lt;p&gt;The next disappointment is coming from both DOTs. Notice that in Scala, a very general
pattern is to have traits mixed together, and during implementation, the programmers
are forced to resolve the multi-inheritance problem, or the compiler will reject the
program. For example, consider the following program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapFoo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;unwrap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapBar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;unwrap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapFoo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapBar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;???&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Dotty, &lt;cite&gt;&amp;amp;&lt;/cite&gt; denotes the intersection type as shown above as &lt;span class="math"&gt;\(\wedge\)&lt;/span&gt;. This is
not a problem, because the programmer needs to resolve what type &lt;cite&gt;unwrap&lt;/cite&gt; is supposed
to have. e.g.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapFoo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapBar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapFoo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;WrapBar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;unwrap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second point here, is that from &lt;cite&gt;x.unwrap&lt;/cite&gt;, we are able to obtain &lt;cite&gt;Foo &amp;amp; Bar&lt;/cite&gt;,
which is more specific than any other types.&lt;/p&gt;
&lt;p&gt;However, this is achievable in none of both.&lt;/p&gt;
&lt;p&gt;In Wadlerfest DOT, there is a very close-looking rule.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : S \quad \Gamma \vdash x : U}
{\Gamma \vdash x : S \wedge U} (And-I)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This looks very close, except that it only operates on variables. To achieve &lt;cite&gt;x.unwrap
: Foo &amp;amp; Bar&lt;/cite&gt; as shown above, there are two possible fixes for Wadlerfest DOT.&lt;/p&gt;
&lt;p&gt;The first one is to generalize the rule above to work for terms.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash t : S \quad \Gamma \vdash t : U}
{\Gamma \vdash t : S \wedge U} (And-I')
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Another solution is to assert that intersection &lt;span class="math"&gt;\(\wedge\)&lt;/span&gt; and data fields are
&lt;em&gt;distributive&lt;/em&gt; from subtyping rule&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{ }
{\Gamma \vdash \{a : S \} \wedge \{a : U\} &amp;lt;: \{ a : S \wedge U \}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;These two fixes would also apply for OOPSLA DOT.&lt;/p&gt;
&lt;p&gt;It's quite awkward to have overlooked this missing features for all well-known
versions of DOTs for so long.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="to-be-fair-what-wadlerfest-dot-is-missing"&gt;
&lt;h3&gt;To Be Fair: What Wadlerfest DOT Is Missing?&lt;/h3&gt;
&lt;p&gt;If I stop here, then I would probably make myself look like I am unilaterally
criticizing, so I guess to make the game fair, I should point out a number of things
that can be done in OOPSLA DOT, but not Wadlerfest DOT.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Wadlerfest DOT has no union types (&lt;span class="math"&gt;\(\vee\)&lt;/span&gt;).&lt;/li&gt;
&lt;li&gt;Objects / recursive types in Wadlerfest DOT have no subtyping relation between
them. This is what led to the comparison to begin with. It's unimaginably strange
that, in an object-oriented setting, there isno subtyping relation among objects.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="takeaways"&gt;
&lt;h2&gt;Takeaways&lt;/h2&gt;
&lt;p&gt;I guess the point of comparing these two calculi are not really for the sake of
comparing them. The purpose should be to learn something from the comparison itself.&lt;/p&gt;
&lt;p&gt;By looking afar, I think the distinctions between the calculi are in no sence
obvious. On the other hand, when people refer to these different versions of DOTs,
each with different expressiveness, &lt;strong&gt;the&lt;/strong&gt; DOT. I think this is a terrible
practice. It would probably make sense, to refer to early versions and a later refined
version, DOT, but once the calculus is stablized, it becomes awkward to connect these
calculi by colliding their names, and makes people think they are different
representations of the same thing, while it's not the case.&lt;/p&gt;
&lt;p&gt;It can be seen there are lots of informal arguments around DOTs. These arguments, very
frequently, are used to connect Dotty and the calculi themselves. For instance, one
might need to show that &lt;em&gt;what&lt;/em&gt; derivation tree in the calculus corresponds to a
desirable type / subtyping relation. However, given how complex the Scala language is,
I suppose it's highly non-trivial to present a consistent encoding from Scala to the
calculus, while this piece of difficult work is normally hand-waved in a discussion
section. For example, In both DOTs, none of the following types mean the same:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\{ A : \bot .. \top \} &amp;amp;\wedge \{ A : \bot .. T \} \\
\{ x \Rightarrow A : \bot .. \top \} &amp;amp;\wedge \{ A : \bot .. T \} \\
\{ x \Rightarrow A : \bot .. \top \} &amp;amp;\wedge \{ x \Rightarrow A : \bot .. T \} \\
\{ A : \bot .. T \} &amp;amp; \\
\{ x \Rightarrow A : \bot .. T \} &amp;amp;
\end{align*}
&lt;/div&gt;
&lt;p&gt;On the other hand, their distinctions are largely hand-waved, because semantically,
they should really be the same.&lt;/p&gt;
&lt;p&gt;Another persepective is that at this point, the specification of the core calculus has
become too complicated. When we try to prove the soundness of the calculi, we are
effectively examining the correctness of the specification using some &lt;em&gt;internal&lt;/em&gt;
properties. However, there are other external aspects: for example, does it represent
Dotty or Scala?&lt;/p&gt;
&lt;p&gt;The last question indicates that the specification of the calculus has already become
non-trivial for experts to understand, and for experts to state what are their
expectations. Subsequently, only misunderstandings follow. In the old days, when
&lt;span class="math"&gt;\(F_{&amp;lt;:}\)&lt;/span&gt; was still a problem, people have studied it for years. At the level of
difficulties of DOT, I think it would worth the same level of effort.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;OOPSLA DOT, OOPSLA 16, &lt;a class="reference external" href="http://lampwww.epfl.ch/~amin/dot/soundness_oopsla16.pdf"&gt;http://lampwww.epfl.ch/~amin/dot/soundness_oopsla16.pdf&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Wadlerfest DOT, Wadlerfest, &lt;a class="reference external" href="https://infoscience.epfl.ch/record/215280/files/paper_1.pdf"&gt;https://infoscience.epfl.ch/record/215280/files/paper_1.pdf&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Scala / DOT"></category><category term="DOT"></category><category term="programming languages"></category><category term="research"></category></entry></feed>