<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Hu's Blogs - Scala / DOT</title><link href="/blogs/" rel="alternate"></link><link href="/blogs/feeds/scala-dot.atom.xml" rel="self"></link><id>/blogs/</id><updated>2019-03-09T00:00:00-05:00</updated><entry><title>Comparison Between Different DOTs</title><link href="/blogs/compare-dots.html" rel="alternate"></link><published>2019-03-09T00:00:00-05:00</published><updated>2019-03-09T00:00:00-05:00</updated><author><name>Jason Hu</name></author><id>tag:None,2019-03-09:/blogs/compare-dots.html</id><summary type="html">&lt;p class="first last"&gt;A comparison between different versions of Dependent Object Types
(DOTs). The thought put in this blog might or might not be published in the
future, but nonetheless something worth mentioning before I entirely forget
about it.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Last week, Ondřej, Marianna and I were discussing the differences between two
different definitions of Dependent Object Types (DOTs). The original motivation was
that I had to make the technical decision of which DOT I am supposed to work on for my
&lt;a class="reference external" href="https://gitlab.com/JasonHuZS/AlgDotCalculus"&gt;Master's thesis&lt;/a&gt;. Though the decision
was made before the discussion occurred, I think the discussion was very fruitful, and
it should be made public. I am not sure if the content from this blog will eventually
become a paper, because it depends on my timeline, as well as Ondřej's. On the other
hand, I suppose it's very important for a researcher who attempts to work on DOT, and
wants to make their technical decision as well.&lt;/p&gt;
&lt;p&gt;Here, I will focus my discussion on OOPSLA DOT &lt;a class="footnote-reference" href="#id3" id="id1"&gt;[1]&lt;/a&gt; and Wadlerfest DOT &lt;a class="footnote-reference" href="#id4" id="id2"&gt;[2]&lt;/a&gt;. Due to
limitation of space, it would directly dive into the technical details, without going
through the definition of the calculi. Going through all the definitions of DOTs
should really be the content of a survey paper, which is not what I am doing now, so
I'd expect this article might appear to be difficult for beginners.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-comparison"&gt;
&lt;h2&gt;The Comparison&lt;/h2&gt;
&lt;p&gt;Following are some discussion on the calculi, but before that, I should probably
describe a main feature in these calculi to make the problem clearer.&lt;/p&gt;
&lt;div class="section" id="path-dependent-types"&gt;
&lt;h3&gt;Path Dependent Types&lt;/h3&gt;
&lt;p&gt;In Scala, a class can have type members. In DOT, we call it type tags.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="k"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="kt"&gt;Bar&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;
&lt;span class="c1"&gt;// then in the future, one may refer to the type inside of Foo&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;x.A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the notation &lt;cite&gt;&amp;gt;:&lt;/cite&gt; means that &lt;cite&gt;Foo&lt;/cite&gt; is some subtype of &lt;cite&gt;A&lt;/cite&gt;, and &lt;cite&gt;&amp;lt;:&lt;/cite&gt; means &lt;cite&gt;Bar&lt;/cite&gt; is
some supertype of &lt;cite&gt;A&lt;/cite&gt;. Now consider the following piece of code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;z1&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;z2&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;x.A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z1&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;cite&gt;x.A&lt;/cite&gt; in the second is what we called path dependent types. We refer to the hidden
type inside of the object via member access. This piece of code shows something very
strange. To begin with, the code has nothing to do with particular &lt;cite&gt;Foo&lt;/cite&gt; or
&lt;cite&gt;Bar&lt;/cite&gt;. That means one can turn any types into any other types. From theoretical point
of view, in the core calculus, we don't really need this assignment sequence to
achieve the same result. Instead, we rely on a fundamental property from the calculus,
transitivity.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash S &amp;lt;: T \quad \Gamma \vdash T &amp;lt;: U}{\Gamma \vdash S &amp;lt;: U} (Trans)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Relying in transitivity, we can derive &lt;cite&gt;z1&lt;/cite&gt; having type &lt;cite&gt;Bar&lt;/cite&gt; immediately. However,
such derivation can only be made possible, if &lt;cite&gt;x&lt;/cite&gt; is in the context to begin
with. Namely, there needs to be some instance of &lt;cite&gt;Foo&lt;/cite&gt; we can refer to: note that path
dependent types only works for existing variables. We refer to this characteristic of
connecting two arbitrary types with a path dependent type (or &lt;em&gt;path&lt;/em&gt; in short), &lt;strong&gt;bad
bounds&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This is a core feature in the new Scala, Dotty, and these two calculi are supposed to
model the behavior of path dependent types.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="context-truncation-in-oopsla-dot"&gt;
&lt;h3&gt;Context Truncation in OOPSLA DOT&lt;/h3&gt;
&lt;p&gt;In OOPSLA DOT, we can discover that the &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules have the following form
(e.g. &lt;span class="math"&gt;\(Sel_1\)&lt;/span&gt;).&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma_{[x]} \vdash x :_! (L : T .. \top)}{\Gamma \vdash T &amp;lt;: x.L} (Sel_1)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;In this notation, &lt;span class="math"&gt;\(\Gamma_{[x]}\)&lt;/span&gt; denotes that the bindings after &lt;span class="math"&gt;\(x\)&lt;/span&gt; from
context &lt;span class="math"&gt;\(\Gamma\)&lt;/span&gt; are truncated (but &lt;span class="math"&gt;\(x\)&lt;/span&gt; is kept).&lt;/p&gt;
&lt;p&gt;On the other hand, Wadlerfest DOT has no such truncation.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : \{L : S .. U \}}{\Gamma \vdash S &amp;lt;: x.L} (Sel_1')
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This treatment, effectively, is used to regulate the behavior of path dependent
types. Note that in OOPSLA DOT, the typing is done via a variant with a bang
subscript. This difference will be discussed in the next section.  For the current
problem, consider the following (strange) program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
       &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;A&lt;/span&gt; &lt;span class="k"&gt;&amp;gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Nothing&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;})&lt;/span&gt;
    &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Consider the generic type of &lt;cite&gt;List&lt;/cite&gt; can be accessed via &lt;cite&gt;x.T&lt;/cite&gt;. In Wadlerfest DOT, this
is a valid program, as witnessed by the following proof.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\dfrac
{\dfrac{x,y \vdash x : List[Any] \quad x,y \vdash List[Any] &amp;lt;: List[Nothing]}
{x,y \vdash x : List[Nothing]}}
{x,y \vdash x.T &amp;lt;: Nothing} (Sel_1/Sel_1')
\end{equation*}
&lt;/div&gt;
&lt;p&gt;For brievity, I omitted the types bound to the variables in the context, and some
sub-derivations that are obvious to see. However, in OOPSLA DOT, the subderivation of
&lt;span class="math"&gt;\(x,y \vdash List[Any] &amp;lt;: List[Nothing]\)&lt;/span&gt; doesn't work. This is because the
context truncation in the &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules. Since &lt;span class="math"&gt;\(x,y \vdash x.T &amp;lt;: Nothing\)&lt;/span&gt;
is a conclusion of &lt;span class="math"&gt;\(Sel_2\)&lt;/span&gt; rule, any sub-derivations after that point have lost
&lt;span class="math"&gt;\(y\)&lt;/span&gt;, and that makes this derivation impossible in the OOPSLA DOT. There doesn't
seem to other way to achieve the same conclusion in OOPSLA DOT either.&lt;/p&gt;
&lt;p&gt;That's why I called context truncation behavior is &lt;strong&gt;regulating&lt;/strong&gt; the behavior of path
dependent types. Due to the context truncation, how a path dependent type can behave
is fixed at its definition time.  There is no way to impose further subtyping relation
after that. Whereas in Wadlerfest DOT, this is possible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="typing-doesn-t-have-pack-rule"&gt;
&lt;h3&gt;&lt;span class="math"&gt;\(:!\)&lt;/span&gt; Typing Doesn't Have &lt;span class="math"&gt;\(Pack\)&lt;/span&gt; rule&lt;/h3&gt;
&lt;p&gt;As briefly mentioned above, there is yet another distinction between these two DOTs,
which is the bang type (&lt;span class="math"&gt;\(:!\)&lt;/span&gt;) in OOPSLA DOT. In OOPSLA DOT, there are following
two rules.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : T^x}{\Gamma \vdash x : \{z \Rightarrow T^z\}} (VarPack)
\quad
\frac{\Gamma \vdash x :_{(!)} \{z \Rightarrow T^z\}}{\Gamma \vdash x :_{(!)} T^x} (VarUnpack)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The subscript &lt;span class="math"&gt;\((!)\)&lt;/span&gt; means that there is variant of the same rule for bang typing
(and without the subscript denote the regular typing). The formulation of these two
rules means that during bang typing, there cannot be &lt;span class="math"&gt;\(VarPack\)&lt;/span&gt; rule. The entries
for bang typing is &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules (see one rule in the previous section). In
Wadlerfest DOT, the similar rules are&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : T^x}{\Gamma \vdash x : \mu\{z : T^z\}} (Rec-I)
\quad
\frac{\Gamma \vdash x : \mu\{z : T^z\}}{\Gamma \vdash x : T^x} (Rec-E)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;The syntax is different but &lt;span class="math"&gt;\(\{x \Rightarrow T^x\}\)&lt;/span&gt; and &lt;span class="math"&gt;\(\mu\{x : T^x\}\)&lt;/span&gt;
are the same thing. They both denote object types, which means all members in their
definitions can refer back to the object reference, and therefore their sibling
definitions as well. Now, consider how disallowing &lt;span class="math"&gt;\(VarPack\)&lt;/span&gt; rule (or
correspondingly &lt;span class="math"&gt;\(Rec-I\)&lt;/span&gt; rule) impact the expressiveness of the calculus.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
T_1 &amp;amp;= \{A : \bot .. \top \} \\
T_2 &amp;amp;= \{A : \bot .. \bot \} \\
T_3 &amp;amp;= \{ foo : x.A \} \\
T_4 &amp;amp;\text{ is irrelevant and not }\top.
\end{align*}
&lt;/div&gt;
&lt;p&gt;The we can consider the following program.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\text{def bar}&amp;amp; (y : \{ B :  \{z \Rightarrow T_1 \wedge T_4 \} .. \{ z \Rightarrow T_2 \wedge T_4\} \} ) \\
              &amp;amp; (x : \{x \Rightarrow T_1 \wedge T_3 \} \wedge T_4) \\
    : &amp;amp; \bot = x.foo
\end{align*}
&lt;/div&gt;
&lt;p&gt;In Wadlerfest, this program is going to compile, because &lt;span class="math"&gt;\(x : \{x \Rightarrow
T_1 \wedge T_4\}\)&lt;/span&gt; can be shown, by first &lt;span class="math"&gt;\(Rec-E\)&lt;/span&gt; rule and then &lt;span class="math"&gt;\(Rec-I\)&lt;/span&gt;
rule. After that, &lt;span class="math"&gt;\(y\)&lt;/span&gt; can be used to prove &lt;span class="math"&gt;\(x : \{x \Rightarrow T_2 \wedge
T_4\}\)&lt;/span&gt;. At this point, we've already got &lt;span class="math"&gt;\(\{A : \bot .. \bot\}\)&lt;/span&gt; and been able to
show &lt;span class="math"&gt;\(x.foo : \bot\)&lt;/span&gt; indeed.&lt;/p&gt;
&lt;p&gt;This, however, is impossible, because there is no way to show &lt;span class="math"&gt;\(x : \{x
\Rightarrow T_2 \wedge T_4\}\)&lt;/span&gt; inside of &lt;span class="math"&gt;\(Sel\)&lt;/span&gt; rules, in which &lt;span class="math"&gt;\(VarPack\)&lt;/span&gt;
rule is forbidden. This gives another point OOPSLA DOT is less expressive than
Wadlerfest DOT.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="multi-inherience-in-dots"&gt;
&lt;h3&gt;Multi-Inherience in DOTs&lt;/h3&gt;
&lt;p&gt;The next disappointment is coming from both DOTs. Notice that in Scala, a very general
pattern is to have traits mixed together, and during implementation, the programmers
are forced to resolve the multi-inheritance problem, or the compiler will reject the
program. For example, consider the following program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;Bar&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;WrapFoo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;unwrap&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;WrapBar&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;unwrap&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Bar&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;WrapFoo&lt;/span&gt; &lt;span class="kt"&gt;&amp;amp;&lt;/span&gt; &lt;span class="kt"&gt;WrapBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;???&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="kt"&gt;&amp;amp;&lt;/span&gt; &lt;span class="kt"&gt;Bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Dotty, &lt;cite&gt;&amp;amp;&lt;/cite&gt; denotes the intersection type as shown above as &lt;span class="math"&gt;\(\wedge\)&lt;/span&gt;. This is
not a problem, because the programmer needs to resolve what type &lt;cite&gt;unwrap&lt;/cite&gt; is supposed
to have. e.g.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;WrapFoo&lt;/span&gt; &lt;span class="kt"&gt;&amp;amp;&lt;/span&gt; &lt;span class="kt"&gt;WrapBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
  &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;WrapFoo&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;WrapBar&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;unwrap&lt;/span&gt; &lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Foo&lt;/span&gt; &lt;span class="kt"&gt;&amp;amp;&lt;/span&gt; &lt;span class="kt"&gt;Bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Bar&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second point here, is that from &lt;cite&gt;x.unwrap&lt;/cite&gt;, we are able to obtain &lt;cite&gt;Foo &amp;amp; Bar&lt;/cite&gt;,
which is more specific than any other types.&lt;/p&gt;
&lt;p&gt;However, this is achievable in none of both.&lt;/p&gt;
&lt;p&gt;In Wadlerfest DOT, there is a very close-looking rule.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash x : S \quad \Gamma \vdash x : U}
{\Gamma \vdash x : S \wedge U} (And-I)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;This looks very close, except that it only operates on variables. To achieve &lt;cite&gt;x.unwrap
: Foo &amp;amp; Bar&lt;/cite&gt; as shown above, there are two possible fixes for Wadlerfest DOT.&lt;/p&gt;
&lt;p&gt;The first one is to generalize the rule above to work for terms.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{\Gamma \vdash t : S \quad \Gamma \vdash t : U}
{\Gamma \vdash t : S \wedge U} (And-I')
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Another solution is to assert that intersection &lt;span class="math"&gt;\(\wedge\)&lt;/span&gt; and data fields are
&lt;em&gt;distributive&lt;/em&gt; from subtyping rule&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\frac{ }
{\Gamma \vdash \{a : S \} \wedge \{a : U\} &amp;lt;: \{ a : S \wedge U \}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;These two fixes would also apply for OOPSLA DOT.&lt;/p&gt;
&lt;p&gt;It's quite awkward to have overlooked this missing features for all well-known
versions of DOTs for so long.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="to-be-fair-what-wadlerfest-dot-is-missing"&gt;
&lt;h3&gt;To Be Fair: What Wadlerfest DOT Is Missing?&lt;/h3&gt;
&lt;p&gt;If I stop here, then I would probably make myself look like I am unilaterally
criticizing, so I guess to make the game fair, I should point out a number of things
that can be done in OOPSLA DOT, but not Wadlerfest DOT.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Wadlerfest DOT has no union types (&lt;span class="math"&gt;\(\vee\)&lt;/span&gt;).&lt;/li&gt;
&lt;li&gt;Objects / recursive types in Wadlerfest DOT have no subtyping relation between
them. This is what led to the comparison to begin with. It's unimaginably strange
that, in an object-oriented setting, there isno subtyping relation among objects.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="takeaways"&gt;
&lt;h2&gt;Takeaways&lt;/h2&gt;
&lt;p&gt;I guess the point of comparing these two calculi are not really for the sake of
comparing them. The purpose should be to learn something from the comparison itself.&lt;/p&gt;
&lt;p&gt;By looking afar, I think the distinctions between the calculi are in no sence
obvious. On the other hand, when people refer to these different versions of DOTs,
each with different expressiveness, &lt;strong&gt;the&lt;/strong&gt; DOT. I think this is a terrible
practice. It would probably make sense, to refer to early versions and a later refined
version, DOT, but once the calculus is stablized, it becomes awkward to connect these
calculi by colliding their names, and makes people think they are different
representations of the same thing, while it's not the case.&lt;/p&gt;
&lt;p&gt;It can be seen there are lots of informal arguments around DOTs. These arguments, very
frequently, are used to connect Dotty and the calculi themselves. For instance, one
might need to show that &lt;em&gt;what&lt;/em&gt; derivation tree in the calculus corresponds to a
desirable type / subtyping relation. However, given how complex the Scala language is,
I suppose it's highly non-trivial to present a consistent encoding from Scala to the
calculus, while this piece of difficult work is normally hand-waved in a discussion
section. For example, In both DOTs, none of the following types mean the same:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{align*}
\{ A : \bot .. \top \} &amp;amp;\wedge \{ A : \bot .. T \} \\
\{ x \Rightarrow A : \bot .. \top \} &amp;amp;\wedge \{ A : \bot .. T \} \\
\{ x \Rightarrow A : \bot .. \top \} &amp;amp;\wedge \{ x \Rightarrow A : \bot .. T \} \\
\{ A : \bot .. T \} &amp;amp; \\
\{ x \Rightarrow A : \bot .. T \} &amp;amp;
\end{align*}
&lt;/div&gt;
&lt;p&gt;On the other hand, their distinctions are largely hand-waved, because semantically,
they should really be the same.&lt;/p&gt;
&lt;p&gt;Another persepective is that at this point, the specification of the core calculus has
become too complicated. When we try to prove the soundness of the calculi, we are
effectively examining the correctness of the specification using some &lt;em&gt;internal&lt;/em&gt;
properties. However, there are other external aspects: for example, does it represent
Dotty or Scala?&lt;/p&gt;
&lt;p&gt;The last question indicates that the specification of the calculus has already become
non-trivial for experts to understand, and for experts to state what are their
expectations. Subsequently, only misunderstandings follow. In the old days, when
&lt;span class="math"&gt;\(F_{&amp;lt;:}\)&lt;/span&gt; was still a problem, people have studied it for years. At the level of
difficulties of DOT, I think it would worth the same level of effort.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;OOPSLA DOT, OOPSLA 16, &lt;a class="reference external" href="http://lampwww.epfl.ch/~amin/dot/soundness_oopsla16.pdf"&gt;http://lampwww.epfl.ch/~amin/dot/soundness_oopsla16.pdf&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Wadlerfest DOT, Wadlerfest, &lt;a class="reference external" href="https://infoscience.epfl.ch/record/215280/files/paper_1.pdf"&gt;https://infoscience.epfl.ch/record/215280/files/paper_1.pdf&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="DOT"></category><category term="programming languages"></category><category term="research"></category></entry></feed>